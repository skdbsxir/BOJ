"""
이전 작동시기에 k광년 이동하면 k-1 or k or k+1만을 이동할 수 있음.
 ex) 처음 작동시키면 -1, 0, 1 이동가능한데, 실제로 보면 1만큼만 이동.
      > 1만큼 이동했으니 그 다음엔 0, 1, 2만큼 이동 가능.
      > 2만큼 이동했으면 그 다음엔 1, 2, 3만큼 이동 가능.

x부터 y까지 최소한의 작동횟수로 이동. y직전은 항상 1.
x->y까지의 필요 최소값?

0부터 3까지 이동?
 > 처음 선택지 -1, 0, 1 -> 1 이동 (0->1) -> 
     선택지 0, 1, 2 -> 다음에 1 (1->2) -> 
     선택지 0, 1, 2 -> 다음에 1 (2->3) (목표직전엔 항상 1) -> 도착     

1부터 5까지 이동?
 > 처음 선택지 -1, 0, 1 -> 1 이동 (1->2) ->
     선택지 0, 1, 2 -> 다음에 2 (2->4) ->
     선택지 1, 2, 3 -> 다음에 1 (4->5) (목표직전엔 항상 1) -> 도착
     
x부터 y까지 이동?
 > 처음(n=0) 선택지 x-1, 0, x+1 -> x+1 이동 (x -> x+1) ->
     선택지 (x+1)-1, (x+1), (x+1) +1 -> (x+1) +1 이동 (x+1 -> (x+1)+1)
     ...
     선택지 (x+(n))-1, x+(n), (x+(n)) +1 -> (x+(n+1)) 이동 ((x+(n)) -> (x+(n))+1)
     ...
     남은거리
항상 최대가되는 선택지를 선택, if 남은거리 == y-1 이면 1 이동.
"""
"""
x부터 y-1까지 이동, 마지막에 +1
 > x ~ y-1 을 반으로 쪼개고 -> 첫 목표는 half보다 크게 가는것.
 > 처음엔 항상 1 선택 -> 그다음 선택지는 0, 1, 2 -> 2 선택 -> 1, 2, 3 -> ...
 > 최근 이동거리에서 y-1까지의 거리는 딱 그만큼만 선택 -> 어떻게 표현할까
 
  >> 첫 목표가 half를 최소한의 횟수로 넘기는거 (point_half)
  >> 그 다음 목표는 point_half에서 y-1까지의 거리가 2이하인 지점까지 가는것 (point_last) (이동량 m)
  >> point_last에서 m-1, m, m+1만큼 이동해 y-1이랑 같아지게 이동.
  
or
 > x ~ y-1을 반으로 쪼갬. 이 범위가 소수점자리면 올림. 이 위치를 point_half.
 > 첫 목표 : point_half까지 최소한의 움직임으로  이동
  >> 이동수는 1부터 1씩 증가하는 증가수열 (a = 1, d = 1인 등차수열.)
 > point_half까지 도착.
 > point_half에서 이동할수 있는 거리 = 직전이동값-1, 직전이동값, 직전이동값+1
  >> point_half에서 point_move 까지 이동
   >>> point_move에서 y-1까지의 거리가 항상 2 이하가 되도록 이동.
   >>> k-1, k, k+1 중 하나가 2가 되도록 이동. --> 그럼 무조건 직전 움직임은 1,2,3 중 하나로 이동.
  >> (y-1) - half ??? 너무 복잡하게 생각한듯.
  >> point_half까지 최대로 이동, 중간부턴 감소?
"""
"""
x부터 y까지 이동 --> 0부터 y-1까지 이동?
"""
"""
x부터 y까지 이동 --> 거리 : y-x. 표를한번 그려보자 
 > y-x, 이동한 동작, 이동할때 한번에 움직일수있는 최대값
  > 1        1                   1
  > 2        1,1                 1
  > 3        1,1,1               1
  > 4        1,2,1               2
  > 5        1,2,1,1             2
  > 6        1,2,2,1             2
  > 7        1,2,2,1,1           2
  > 8        1,2,2,2,1           2
  > 9        1,2,3,2,1           3
  > 10       1,2,3,2,2,1         3
  > 16       1,2,3,4,3,2,1       4
  > 25       1,2,3,4,5,4,3,2,1   5 그리기ㅅㅂ
이동한 동작이 양끝 1 -> 짝수번째에 동작이 1번씩 추가되고 가운데값이 +1되서 생김
4에서 이동동작 2가생기고, 9에서 이동동작 3이 생기고? 제곱수? 16에서 이동동작 4가 생기네

거리가 N이면 한번에 움직일수있는 최대값음 sqrt(N)이되네. 근데?
dist (y-x) = N -> maxMove = sqrt(N)
제곱수일때 동작횟수?
1-1, 4-3, 9-5, 16-7, 25-9 --> 제곱수 N에따라 동작횟수가 13579 -> 2N-1형태네. 근데?
"""
import math
# x = 1, y = 5 이라면? 거리가 4
# x = 1, y = 10 이라면? 거리가 9
# x = 1, y = 17 이라면? 거리가 16
# x = 1, y = 26 이라면? 거리가 25
x, y = map(int, input().split())
dist = y - x # dist N = y - x = 4 이고 // dist = y - x = 9 이고 // dist = 16이고 // dist = 25이고
maxMove = math.sqrt(dist) # 최대 이동값은 2가 될것이고 // 최대이동값은 3이 될것이고 // 4가 될것이고 // 5가 될것이고
# 동작횟수 = 2 * 제곱수N - 1 --> 2 * maxMove(dist) - 1
countNum = 2 * maxMove - 1

print(int(countNum))
# 이걸 어떻게 일반화하지... 




