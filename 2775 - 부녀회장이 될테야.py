"""
a층의 b호에 살려면 자신의 아래(a-1)층의 1호부터 b호까지 사람들의 수의 합만큼 사람들을 데려와 살아야 한다.
비어있는 집은 없고 모든 거주민들이 이 계약 조건을 지키고 왔다.
양의 정수 k와 n에 대해 k층에 n호에는 몇 명이 살고 있는지 출력.

아파트에는 0층부터 있고 각층에는 1호부터 있으며, 0층의 i호에는 i명이 산다.
k층에 n호에는 몇 명이 살고 있는지 출력.

2층 3호에 살려면 자신의 아래 2-1=1층의 1호부터 3호까지 사람들의 수의 합만큼 사람들을 데려와 살아야 한다.

 1 <= k, n <= 14
"""
# 테스트 케이스 수
T = int(input())

# k = 층 위치 // n = 호수
# k = int(input())
# n = int(input())

# print(T, k, n)

# 예제 k = 1, b = 3 --> 1층 3호에 살려면 자신의 아래 0층 1호부터 3호까지 사는사람 수를 데려와야함.
# (0,1), (0,2), (0,3)에 사는 사람들을 데려와야 한다는 소리.
# 이 사람들이 총 몇명이냐? 답은 6이래. 왜? bCk 인가? 3C1 = 3! / 2! * 1! = 3*2 / 2 = 3인데?
# 모든 거주민이 이 계약조건을 지키고 왔다. 0층의 i호에는 i명이 사니까
# (0,1)=1, (0,2)=2, (0,3)=3 ... (0,i)=i

# 예제 k = 2, b = 3 --> 2층 3호에 살려면 자신아래 1층 1호부터 3호까지 사는사람 수를 데려와야 함.
# (1,1), (1,2), (1,3)
# (1,1)은 자신아래 (0,1)만큼의 사람수를 데려와야 함. --> 총 1명 거주
# (1,2)는 자신아래 (0,1), (0,2)만큼의 사람수를 데려와야함 --> 1 + 2 = 3명거주
# (1,3)은 자신아래 (0,1), (0,2), (0,3)만큼의 사람수를 데려와야 함 --> 1 + 2 + 3 = 6명 거주
# 그러면 (2,3)에 사는 사람은 1+3+6 = 10명의 사람을 데려와야 함.

# (0, i)에는 i명이 살고
# 매 (k,1)에는 1명이 살고
# (k,n)에 살려면 (k-1, 1) + ... + (k-1, n) 수 만큼 데려와야 함.
# (k,n) = (k-1, 1) + sigma(i=2 to n)[(k-1, n)] 인 셈. (k>=1)

"""
for i in range(k) ?
    (k, 1) = 1 ?
    
if k = 0 이면
    (k, n) = n
elif k >= 1 이면
    (k, n) = (k-1, 1) + (k-1, 2) + (k-1, 3) + ... + (k-1, n) 
"""
# 이차원배열을 선언하는게 맞는듯. 아닌가?
# 아래층을 전부 더할 필요 없이, '왼쪽집 + 아랫집' 수 인가???????? 으앙맞다
# (k,n) = (k, n-1) + (k-1, n)
"""
k_0 = [x for x in range(1, n + 1)] # 0층 거주자들.

# 층 위치만큼 반복,
for i in range(k) :
    # 1 ~ n-1까지
    for j in range(1, n) :
        # 각 층의 사람수를 변경.
        k_0[j] += k_0[j-1]
print(k_0[-1]) # n호는 리스트의 맨 끝원소.
"""
# 1 <= k, n <= 14
def towerMap(x, y) :
    # x층 y호 만큼의 2차원 리스트 생성.
    # ex) x=1, y=2 이면 towerList의 shape : (2, 3)
    """
    (1,1)(1,2)(1,3)
    (0,1)(0,2)(0,3)
    """
    towerList = [[0 for j in range(y)] for i in range(x+1)]
    for i in range(x+1) :
        towerList[i][0] = 1 # 각 층의 1호(index=0) 거주자 수는 1명.
    for i in range(y) :
        towerList[0][i] = i+1 # 0층의 i호는 i명.
    
    for i in range(1, x+1):
        for j in range(1, y):
            towerList[i][j] = towerList[i][j-1] + towerList[i-1][j]
    
    #print(towerList)
    return towerList[x][y-1] # 빌어쳐먹을 인덱스

for i in range(T) :
    k = int(input())
    n = int(input())
    print(towerMap(k,n))
    